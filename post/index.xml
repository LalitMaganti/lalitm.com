<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Lalit Maganti</title><link>/post/</link><description>Recent content in Posts on Lalit Maganti</description><generator>Hugo</generator><language>en</language><lastBuildDate>Sun, 12 Oct 2025 00:00:00 +0000</lastBuildDate><atom:link href="/post/index.xml" rel="self" type="application/rss+xml"/><item><title>What Makes a Good Tool for Claude Code</title><link>/writing-tools-for-claude-code/</link><pubDate>Sun, 12 Oct 2025 00:00:00 +0000</pubDate><guid>/writing-tools-for-claude-code/</guid><description>&lt;p&gt;I&amp;rsquo;ve been using Claude Code extensively for personal projects, and similar AI
coding tools at work. Recently I came across
&lt;a href="https://www.alephic.com/writing/the-magic-of-claude-code"&gt;this excellent blog post&lt;/a&gt;
that resonated with a lot of my experience.&lt;/p&gt;
&lt;p&gt;One part stuck with me though: Noah emphasizes that tools fail with LLMs when
they&amp;rsquo;re &amp;ldquo;overly complex,&amp;rdquo; with the Unix philosophy being particularly
well-suited for tool calling. But then I thought about &lt;code&gt;git&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Git breaks the Unix philosophy completely. It&amp;rsquo;s sprawling, stateful, and
complex. And yet Claude Code handles it effortlessly. It composes commands that,
even after 10+ years of daily git usage, I wouldn&amp;rsquo;t think to use. It handles
rebasing, cherry-picking, complex resetsâ€”stuff that trips up experienced
developers regularly.&lt;/p&gt;</description></item><item><title>Harnessing Frustration: Using LLMs to Overcome Activation Energy</title><link>/llm-motivation-via-emotions/</link><pubDate>Mon, 14 Jul 2025 00:00:00 +0000</pubDate><guid>/llm-motivation-via-emotions/</guid><description>&lt;p&gt;One of my biggest weaknesses as a software engineer is procrastination when
facing a new project. When the scope is unclear, I have a tendency to wait until
I feel I&amp;rsquo;ve &amp;ldquo;felt out&amp;rdquo; the problem to start doing anything. I know I&amp;rsquo;ll feel
better and work much faster when I get &amp;ldquo;stuck in&amp;rdquo; but I still struggle with that
first step, overcoming the &amp;ldquo;activation energy&amp;rdquo; required to engage with the
details.&lt;/p&gt;</description></item><item><title>V4L2 and Hardware Encoding on the Raspberry Pi</title><link>/hw-encoding-raspi/</link><pubDate>Mon, 01 Feb 2021 23:00:00 +0000</pubDate><guid>/hw-encoding-raspi/</guid><description>&lt;p&gt;&lt;strong&gt;TLDR&lt;/strong&gt;: Explain how the V4L2 M2M API works through the use-case of
implementing hardware video encoding on the Raspberry Pi. This knowledge is
generally useful as V4L2 is the de-facto generic API for hardware decoding and
encoding on Linux.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Background&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;My journey started at
&lt;a href="https://www.youtube.com/watch?v=CyEpshm16HY&amp;amp;t=139s"&gt;this video&lt;/a&gt; on the
excellent
&lt;a href="https://www.youtube.com/channel/UCp3yVOm6A55nx65STpm3tXQ"&gt;Craft Computing&lt;/a&gt;
YouTube channel which showed how to setup TinyPilot, a Python app for KVM over
IP which runs on a Raspberry Pi. Behind the scenes, TinyPilot uses
&lt;a href="https://github.com/pikvm/ustreamer"&gt;ustreamer&lt;/a&gt; to read frames from a HDMI
capture card and either exposes it over HTTP or writes it to shared memory.
Along with the MJPEG output, support was recently added for encoding video using
H264.&lt;/p&gt;</description></item></channel></rss>