<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Lalit Maganti</title><link>/</link><description>Recent content on Lalit Maganti</description><generator>Hugo</generator><language>en</language><lastBuildDate>Sun, 19 Oct 2025 19:38:00 +0100</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml"/><item><title>TIL: The Documentation System (Divio)</title><link>/til-the-documentation-system-divio/</link><pubDate>Sun, 19 Oct 2025 19:38:00 +0100</pubDate><guid>/til-the-documentation-system-divio/</guid><description>&lt;p&gt;I, and the rest of the Perfetto team, spent a lot of time earlier this year rewriting the &lt;a href="docs.perfetto.dev"&gt;Perfetto documentation&lt;/a&gt; to be more useful for the average developer. As part of this we struggled a lot to figure out &amp;ldquo;what is the best way to structure our documentation&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;Today, when reading &lt;a href="https://rakhim.exotext.com/examples-are-the-best-documentation"&gt;Examples are the best documentation&lt;/a&gt;, I came across &lt;a href="https://docs.divio.com/documentation-system/how-to-guides/"&gt;The Documentation System&lt;/a&gt;, an approach to structuring developer documentation. Reading through it, I couldn&amp;rsquo;t help but marvel at how clear and concisely it laid out the ideas we were struggling to come up with from first principles.&lt;/p&gt;</description></item><item><title>On Perfetto, Open Source, and Company Priorities</title><link>/perfetto-oss-company-prio/</link><pubDate>Fri, 17 Oct 2025 15:00:00 +0100</pubDate><guid>/perfetto-oss-company-prio/</guid><description>&lt;p&gt;I recently stumbled across
&lt;a href="https://lobste.rs/s/fl7ly9/traceboot_precise_lightweight_tracing"&gt;this post on lobste.rs&lt;/a&gt;
about a project called
&lt;a href="https://codeberg.org/SpecialSnowflake/traceboot"&gt;traceboot&lt;/a&gt; which allows
visualizing the Linux boot process using lightweight ftrace events and Perfetto.
The author had
&lt;a href="https://codeberg.org/SpecialSnowflake/traceboot#woes-with-a-rant-and-ideas-last-paragraph-of-this-section"&gt;some commentary&lt;/a&gt;
about their experience trying to order tracks in Perfetto:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Ordering tracks with perfetto has been ridiculously complicated. It has taken
the majority of the time of this project! Upstream&amp;rsquo;s answers are basically
that the main user is Android (Perfetto is a Google project) so others come
second if at all. While I get the reasons to do so, I read that as a caution
against depending on it as a third-party. Google is notorious for (&amp;hellip;)
completely killing projects&lt;/p&gt;</description></item><item><title>What Makes a Good Tool for Claude Code</title><link>/writing-tools-for-claude-code/</link><pubDate>Sun, 12 Oct 2025 00:00:00 +0000</pubDate><guid>/writing-tools-for-claude-code/</guid><description>&lt;p&gt;I&amp;rsquo;ve been using Claude Code extensively for personal projects, and similar AI
coding tools at work. Recently I came across
&lt;a href="https://www.alephic.com/writing/the-magic-of-claude-code"&gt;this excellent blog post&lt;/a&gt;
that resonated with a lot of my experience.&lt;/p&gt;
&lt;p&gt;One part stuck with me though: Noah emphasizes that tools fail with LLMs when
they&amp;rsquo;re &amp;ldquo;overly complex,&amp;rdquo; with the Unix philosophy being particularly
well-suited for tool calling. But then I thought about &lt;code&gt;git&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Git breaks the Unix philosophy completely. It&amp;rsquo;s sprawling, stateful, and
complex. And yet Claude Code handles it effortlessly. It composes commands that,
even after 10+ years of daily git usage, I wouldn&amp;rsquo;t think to use. It handles
rebasing, cherry-picking, complex resets—stuff that trips up experienced
developers regularly.&lt;/p&gt;</description></item><item><title>Harnessing Frustration: Using LLMs to Overcome Activation Energy</title><link>/llm-motivation-via-emotions/</link><pubDate>Mon, 14 Jul 2025 00:00:00 +0000</pubDate><guid>/llm-motivation-via-emotions/</guid><description>&lt;p&gt;One of my biggest weaknesses as a software engineer is procrastination when
facing a new project. When the scope is unclear, I have a tendency to wait until
I feel I&amp;rsquo;ve &amp;ldquo;felt out&amp;rdquo; the problem to start doing anything. I know I&amp;rsquo;ll feel
better and work much faster when I get &amp;ldquo;stuck in&amp;rdquo; but I still struggle with that
first step, overcoming the &amp;ldquo;activation energy&amp;rdquo; required to engage with the
details.&lt;/p&gt;</description></item><item><title>V4L2 and Hardware Encoding on the Raspberry Pi</title><link>/hw-encoding-raspi/</link><pubDate>Mon, 01 Feb 2021 23:00:00 +0000</pubDate><guid>/hw-encoding-raspi/</guid><description>&lt;p&gt;&lt;strong&gt;TLDR&lt;/strong&gt;: Explain how the V4L2 M2M API works through the use-case of
implementing hardware video encoding on the Raspberry Pi. This knowledge is
generally useful as V4L2 is the de-facto generic API for hardware decoding and
encoding on Linux.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Background&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;My journey started at
&lt;a href="https://www.youtube.com/watch?v=CyEpshm16HY&amp;amp;t=139s"&gt;this video&lt;/a&gt; on the
excellent
&lt;a href="https://www.youtube.com/channel/UCp3yVOm6A55nx65STpm3tXQ"&gt;Craft Computing&lt;/a&gt;
YouTube channel which showed how to setup TinyPilot, a Python app for KVM over
IP which runs on a Raspberry Pi. Behind the scenes, TinyPilot uses
&lt;a href="https://github.com/pikvm/ustreamer"&gt;ustreamer&lt;/a&gt; to read frames from a HDMI
capture card and either exposes it over HTTP or writes it to shared memory.
Along with the MJPEG output, support was recently added for encoding video using
H264.&lt;/p&gt;</description></item><item><title>About</title><link>/page/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/page/about/</guid><description>&lt;p&gt;I&amp;rsquo;m a Senior Staff Software Engineer at Google working on
&lt;a href="https://perfetto.dev"&gt;Perfetto&lt;/a&gt;, an open source suite of tools for performance
tracing and analysis. I&amp;rsquo;ve joined Perfetto as a founding engineer in 2017 and
have been part of the project ever since.&lt;/p&gt;
&lt;p&gt;Perfetto is the default tracing system for Android and Chrome, and is now used
by companies like Meta and Microsoft, as well as in open source projects
like QEMU, Mesa and the Linux kernel. My work focuses on trace analysis
tools — particularly the PerfettoSQL language and its query engine — and championing
the use of Perfetto by open source projects and the industry more broadly.&lt;/p&gt;</description></item></channel></rss>