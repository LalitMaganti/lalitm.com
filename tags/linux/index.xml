<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Linux on Lalit Maganti</title><link>https://lalitm.com/tags/linux/</link><description>Recent content in Linux on Lalit Maganti</description><generator>Hugo</generator><language>en</language><lastBuildDate>Fri, 31 Oct 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://lalitm.com/tags/linux/index.xml" rel="self" type="application/rss+xml"/><item><title>Perfetto: Swiss Army Knife for Linux Client Tracing</title><link>https://lalitm.com/perfetto-swiss-army-knife/</link><pubDate>Fri, 31 Oct 2025 00:00:00 +0000</pubDate><guid>https://lalitm.com/perfetto-swiss-army-knife/</guid><description>&lt;p&gt;&lt;em&gt;Discussed on &lt;a href="https://lobste.rs/s/6c86lq/perfetto_swiss_army_knife_for_linux"&gt;lobste.rs&lt;/a&gt; and &lt;a href="https://news.ycombinator.com/item?id=45771019"&gt;Hacker News&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;I gave a talk at the &lt;a href="https://tracingsummit.org/"&gt;2025 Tracing Summit&lt;/a&gt; last month titled &amp;ldquo;&lt;a href="https://cfp.tracingsummit.org/ts2025/talk/TKVU8W/"&gt;Perfetto: The Swiss Army Knife of Linux Client/Embedded Tracing&lt;/a&gt;&amp;rdquo;. My goal in this talk was to show how Linux kernel, systems and embedded developers can use &lt;a href="https://docs.perfetto.dev"&gt;Perfetto&lt;/a&gt; when debugging and root-causing performance issues in their respective domains. Even though the Perfetto UI is primarily built for viewing &lt;a href="https://perfetto.dev/docs/#why-would-you-use-perfetto-"&gt;Android or Chrome traces&lt;/a&gt;, it is a flexible tool and can be used in many other ways!&lt;/p&gt;
&lt;p&gt;The talk was recorded and is available on &lt;a href="https://www.youtube.com/watch?v=VzTwul2Qb3g"&gt;YouTube&lt;/a&gt;. Taking inspiration from &lt;a href="https://simonwillison.net/"&gt;Simon Willison&lt;/a&gt;, this post is an &lt;a href="https://simonwillison.net/2023/Aug/6/annotated-presentations/"&gt;annotated presentation&lt;/a&gt; containing my slides and detailed notes on them. The talk also has a lot of UI demos: for these, I&amp;rsquo;ll have a screenshot but also a link to the relevant part of the video (videos are unbeatable for UI!).&lt;/p&gt;
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%;"&gt;
 &lt;iframe style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;" src="https://www.youtube.com/embed/VzTwul2Qb3g" title="TS2025 - Perfetto: The Swiss Army Knife of Linux Client/Embedded Tracing" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;
&lt;hr&gt;
&lt;p&gt;First, what is Perfetto? Perfetto is fundamentally a suite of tools: it&amp;rsquo;s not just one thing but a bunch of different tools working together to help you debug and root-cause problems. This diagram shows how everything fits together, with the core parts of the Perfetto project in the center.&lt;/p&gt;
&lt;center&gt;
&lt;p&gt;&lt;img src="https://lalitm.com/img/perfetto-swiss-army-03.jpg" alt="diagram of all the pieces of Perfetto, Recording tools, protobuf format, trace processor, Perfetto UI, Python API, Format converters. Chrome JSON, Other profiling formats"&gt;&lt;/p&gt;
&lt;/center&gt;
&lt;p&gt;The recording tools for Perfetto consist of 1) an &lt;a href="https://perfetto.dev/docs/getting-started/in-app-tracing"&gt;SDK for C++ apps&lt;/a&gt; 2) a &lt;a href="https://perfetto.dev/docs/getting-started/system-tracing"&gt;daemon&lt;/a&gt; that can collect data from ftrace, /proc, /sys, and various kernel interfaces 3) another &lt;a href="https://perfetto.dev/docs/concepts/service-model"&gt;daemon&lt;/a&gt; that amalgamates trace data from multiple processes into a single trace file. These tools all speak the Perfetto &lt;a href="https://perfetto.dev/docs/getting-started/converting"&gt;protobuf format&lt;/a&gt;, a high-performance trace format designed to be very efficient to write but not to analyze or consume directly.&lt;/p&gt;
&lt;p&gt;That&amp;rsquo;s where the &lt;a href="https://perfetto.dev/docs/analysis/trace-processor"&gt;trace processor&lt;/a&gt; comes in. It&amp;rsquo;s a C++ library that parses the protobuf format, but also a bunch of other widely used trace formats. It exposes this data via an SQL query interface to any embedding program including &lt;a href="https://perfetto.dev/docs/visualization/perfetto-ui"&gt;Perfetto UI&lt;/a&gt; (which is what most of this talk is about) and also to the &lt;a href="https://perfetto.dev/docs/analysis/trace-processor-python"&gt;Python API&lt;/a&gt; if you want to do ad-hoc scripting or analysis in Python.&lt;/p&gt;
&lt;p&gt;There are also very common tracing/profiling formats used by the Linux community: perf.data, ftrace text format, Firefox profiler format, and many others. Perfetto &lt;a href="https://perfetto.dev/docs/getting-started/other-formats"&gt;supports&lt;/a&gt; quite a few of those directly. There&amp;rsquo;s also the Chrome JSON format (AKA the &lt;a href="https://docs.google.com/document/d/1CvAClvFfyA5R-PhYUmn5OOQtYMH4h6I0nSsKchNAySU/preview?tab=t.0"&gt;Trace Event Format&lt;/a&gt;) which is a simpler interchange format. It&amp;rsquo;s not the most efficient to read or write, but it does the job for a lot of use cases.&lt;/p&gt;
&lt;p&gt;Often people write &lt;a href="https://perfetto.dev/docs/getting-started/converting"&gt;converters&lt;/a&gt;. They have their own tracing format, maybe proprietary, maybe open source but something we don&amp;rsquo;t know about, and it&amp;rsquo;s very common that people convert to one of the formats we understand, most commonly our protobuf or Chrome JSON formats.&lt;/p&gt;
&lt;center&gt;
&lt;p&gt;&lt;img src="https://lalitm.com/img/perfetto-swiss-army-04.jpg" alt="Slide showing Perfetto UI architecture with web-based trace visualizer features"&gt;&lt;/p&gt;
&lt;/center&gt;
&lt;p&gt;The &lt;a href="https://perfetto.dev/docs/visualization/perfetto-ui"&gt;Perfetto UI&lt;/a&gt; is fundamentally a web-based trace visualizer, combining timeline visualization, user-driven selection/aggregation, and SQL queries all in one interface. Because it has the trace processor as a backend, it works with a bunch of different trace formats.&lt;/p&gt;
&lt;p&gt;It&amp;rsquo;s very important to note that even though the Perfetto UI is web-based, everything happens inside your browser and trace data never leaves your system. You can even &lt;a href="https://perfetto.dev/docs/contributing/ui-getting-started"&gt;build it&lt;/a&gt; and host it yourself on any static server: we&amp;rsquo;ve made it extremely easy to do so!&lt;/p&gt;
&lt;p&gt;At the start of 2025, we actually moved our whole development to GitHub. In the past, we used to develop on Android and GitHub was just a mirror. That&amp;rsquo;s no longer the case, GitHub is actually where we develop and take pull requests.&lt;/p&gt;
&lt;center&gt;
&lt;p&gt;&lt;img src="https://lalitm.com/img/perfetto-swiss-army-05.jpg" alt="Slide introducing the fractal renderer demo program with Vulkan and multi-threading"&gt;&lt;/p&gt;
&lt;/center&gt;
&lt;p&gt;Most of this talk, I&amp;rsquo;m going to spend actually showing you how you can use the Perfetto UI to debug performance issues on Linux. I don&amp;rsquo;t want to show you an Android trace which needs a lot of context about how the Android system works and so you think, &amp;ldquo;oh, that was cool, but I didn&amp;rsquo;t really understand what was happening.&amp;rdquo;&lt;/p&gt;
&lt;p&gt;So to make this talk more approachable, I wrote a &lt;a href="https://github.com/LalitMaganti/fractal-renderer-vk"&gt;straightforward demo program&lt;/a&gt; you can look at yourself! So it&amp;rsquo;s obviously not a production system but I&amp;rsquo;ve tried to make it as representative of the sort of issues we use Perfetto for every day.&lt;/p&gt;
&lt;p&gt;It&amp;rsquo;s a Rust program which generates a Julia set and visualizes it over time. The technologies I used: &lt;a href="https://vulkano.rs/"&gt;Vulkan&lt;/a&gt;, GPU rendering and also multi-threaded CPU computation. So how it works is that computation of various parameters is happening on background threads, and then that&amp;rsquo;s being passed to the main thread for rendering.&lt;/p&gt;
&lt;p&gt;And then, for demonstration purposes, there is a performance bug; rendering should run at 60 FPS, but every so often, the frame rate drops dramatically. Here&amp;rsquo;s what that looks like:&lt;/p&gt;
&lt;center&gt;
&lt;p&gt;&lt;img src="https://lalitm.com/img/test.avif" alt="Animated visualization of Julia set fractal renderer showing frame rate drops"&gt;&lt;/p&gt;
&lt;/center&gt;
&lt;p&gt;The code is on &lt;a href="https://github.com/LalitMaganti/fractal-renderer-vk"&gt;GitHub&lt;/a&gt; and if you&amp;rsquo;re interested in following along. The traces are there as well - you don&amp;rsquo;t have to collect the traces yourself, but you can if you want. All the instructions and information is in the README.&lt;/p&gt;
&lt;center&gt;
&lt;p&gt;&lt;img src="https://lalitm.com/img/perfetto-swiss-army-06.jpg" alt="Slide titled &amp;ldquo;Suspicion #1: Maybe it&amp;rsquo;s a CPU problem?&amp;rdquo; with perf command examples"&gt;&lt;/p&gt;
&lt;/center&gt;
&lt;p&gt;So the first suspicion we may have is that maybe it&amp;rsquo;s some CPU problem. A lot of engineers I know would reach for perf immediately whenever they see a problem like this. The main reason is that if perf can capture the problem, they can go straight to the line of code without needing to spend time debugging using more complex approaches.&lt;/p&gt;</description></item><item><title>V4L2 and Hardware Encoding on the Raspberry Pi</title><link>https://lalitm.com/hw-encoding-raspi/</link><pubDate>Mon, 01 Feb 2021 23:00:00 +0000</pubDate><guid>https://lalitm.com/hw-encoding-raspi/</guid><description>&lt;p&gt;&lt;strong&gt;TLDR&lt;/strong&gt;: Explain how the V4L2 M2M API works through the use-case of
implementing hardware video encoding on the Raspberry Pi. This knowledge is
generally useful as V4L2 is the de-facto generic API for hardware decoding and
encoding on Linux.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Background&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;My journey started at
&lt;a href="https://www.youtube.com/watch?v=CyEpshm16HY&amp;amp;t=139s"&gt;this video&lt;/a&gt; on the
excellent
&lt;a href="https://www.youtube.com/channel/UCp3yVOm6A55nx65STpm3tXQ"&gt;Craft Computing&lt;/a&gt;
YouTube channel which showed how to setup TinyPilot, a Python app for KVM over
IP which runs on a Raspberry Pi. Behind the scenes, TinyPilot uses
&lt;a href="https://github.com/pikvm/ustreamer"&gt;ustreamer&lt;/a&gt; to read frames from a HDMI
capture card and either exposes it over HTTP or writes it to shared memory.
Along with the MJPEG output, support was recently added for encoding video using
H264.&lt;/p&gt;
&lt;p&gt;Even after messing with the source code, I could not get the H264 encoding
working on my Pi running 64-bit Ubuntu with an error message of
&lt;code&gt;Can't create MMAL wrapper&lt;/code&gt;. Digging further, I ran into some insurmountable
roadblocks with the approach taken by ustreamer and discovered the complex state
of hardware encoding on the Pi.&lt;/p&gt;</description></item></channel></rss>